// ========================================================================= //
// Talos - A 3D game engine with network multiplayer.
// Copyright(C) 2015 Jordan Sparks <unixunited@live.com>
//
// This program is free software; you can redistribute it and / or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
// ========================================================================= //
// File: work-log.txt
// Author: Jordan Sparks <unixunited@live.com>
// ========================================================================= //
// A log of all work done on the program.
// ========================================================================= //

== 1/19/15 - 1/26/15 ==
* Read "Game Programming Patterns" by Robert Nystrom in hopes to build a strong design background before starting.

== 1/26/15 ==
'''Prepared for building a consolidated engine.'''
* Built Ogre3D dependencies--FreeImage, FreeType, zlib, and zziplib.
* Built Ogre3D(1.9.0) binaries from latest source.
* Applied for NVIDIA GameWorks to acquire PhysX SDK, then downloaded Core PhysX SDK(3.3.2).
* Built RakNet(4.081) binaries.
* Built CEGUI(0.8.4) binaries (getting CMake to work for this was a little tricky).
* Acquired irrKlang(1.5.0) SDK.
* Acquired SDL2(2.0.3) development libraries.
'''---'''
* Created Visual Studio 12.0 solution. Added main.cpp, compiled and linked with Ogre3D and Boost successfully.
* Created Engine class, which initializes Ogre and will manage the engine states (menu, game, pause, etc.).
* Added stdafx.hpp.
* Added EngineState class, which is abstract; derived classes represent a single state that can be active at a time. The IntroState has been created as a test.
* Added EngineState::injectDependencies() which as of now takes pointers to Ogre::Root and Ogre::Viewport initialized by Engine. This can be later expanded to take a struct or perhaps generics. The prevents me from having to use Engine as a singleton by giving each EngineState the objects they need.
* Tested basic game loop updating and active state updating.

== 1/27/15 ==
* Added Engine::registerState(). This should be called in for each state that will be needed during initialization.
* Added Assert(exp, desc) macro, which tests an expression for true and offers the option to break into the debugger if the expression is false. A description is also supplemented for each Assert.
* Added HelperFunctions.hpp which for now contains a generic toString() function for converting just about anything to std::string.
* Tried to add a basic mesh and a prefab cube and render it with Direct3D11, however errors were occurring which probably had to do with the shaders I'm using or a bug in the engine. Apparently, Direct3D11 support is not even fully implemented yet, so I may have to use the OpenGL rendering system for the duration of this project.
* OpenGL shaders working on a basic mesh.
* Implemented a game loop that uses a fixed time step when updating the state but adjusts for lost time during the rendering phase. Once physics support has been added, it should be "free" and hence the game world will be deterministic.
* Researched some Entity-component system implementations. Everyone seems to have their own way of doing it, so I'll just have to try it. One of my main goals is to store the components in contiguous memory to optimize cache hits.

== 1/28/15 ==
* Created base Component and Entity classes. These are abstract; Component can be derived from into a chain (e.g., Component <- InputComponent <- DemoInputComponent) and Entity should only be derived from once per entity (e.g., Entity <- Player, Entity <- Elevator, Entity <- Gun).
* Created SceneComponent which holds an Ogre::SceneNode to hold the transform in the game world.
* Made System interface. Each type of component should have its own system (e.g., PhysicsSystem, SceneSystem, ModelSystem, etc.).
* Created World class which will hold all data for the game world. Each EngineState has one.
* Created CameraComponent.
* Created Player class derived from Entity. Added a SceneComponent and CameraComponent. Tested for rendering successfully.

== 1/29/25 ==
* Modified Entity class to have init(), destroy(), and update() functions implemented. All of these simply traverse the list of Components stored in the Entity. 
* Component now has pure virtual methods init(), destroy(), update(), all of which take EntityPtr and World& parameters.
* Added SceneComponent::attachObject() which takes an Ogre::MovableObject* and attaches it to the internal Ogre::SceneNode*.
* Created EntityPool class, which has O(1) creation time when retrieving the next available Entity from the contiguous array.
* Delegated Entity creation to the World class, which holds an EntityPool and calls upon it internally.
* Decoupled SceneComponent from CameraComponent::init(). Use CameraComponent::getCamera() and pass it into SceneComponent::attachObject().
* Added FirstPersonComponent which sets up a system of nodes that control a first person camera.
* Added SDL2 and associated the SDL window with the window created by Ogre. 
* Added Message struct in Component folder. Also enums for message types.
* Tested input with SDL, setup mouse motion event to move camera.

== 1/30/15 ==
* Added Entity::message() which broadcasts a message to all attached components.
* Created InputComponent which detects input and sends a corresponding message to the parent Entity.
* Added pitch limitation in FirstPersonComponent, so the camera can't be pitched to an upside down state.
* Made World a friend class of EntityPool, added World::update() which iterates through the EntityPool and calls update on each Entity.

== 1/31/15 ==
* Created ComponentPool generic class. 
* Added ComponentPool instances to World for each type of Component. This increases coupling here but Component creation can be confined to the World class rather than allowing dynamic allocation on the fly.
* Tested an Entity with an ogrehead.mesh ModelComponent. It rotates at the same rate regardless of frame rate, so my update architecture is indeed frame rate indepedent. Just the mouse relative coordinates depend on the frame time.

== 2/2/15 ==
* Removed EngineState::injectDepedencies and created World::injecteDependencies. It's called in Engine::registerState().
* Added World::Dependencies struct for easy parameter passing and change if needed.
* Started integrating CEGUI. Turns out after compiling CEGUi it generated three headers (Config.h, ModuleConfig.h, and Version.h) which should be copied to the main include directory for CEGUI.
* Got a basic CEGUI window setup inside the viewport.
* Synced the CEGUI mouse position using GUIContext::injectMousePosition().
* Removed window creation from Ogre and let SDL create the window. This way, I have more control over mouse behavior without having to resort to Win32 API. So I can now lock the mouse at the center for camera movement. It can be
    disable for using the GUI. After the SDL_Window is created, Ogre calls Root::createRenderWindow() using a window handle parameter retrieved from the SDL_Window. 
    The call to CEGUI::OgreRenderer::bootstrapSystem() also needs a dereferenced Root::getRenderTarget("window name") for initialization.
* Added Input class which takes SDL events and handles them, for player input and GUI input.
* Removed InputComponent as the new Input class takes over. 

== 2/3/15 ==
* Added Observer and Subject classes. 
* Made Engine derive from Observer; it receives notifications from EngineStates. So if it receives a "POP" notification from the active state, it will pop that state.

== 2/6/15 ==
* Renamed FirstPersonComponent to ActorComponent, which can be used to control an Entity using either a player, AI, or network player (also replays).
* Added Command interface class. Command::execute() takes an EntityPtr and can retrieve the components it might need from that pointer.
* Added a std::map to the Input class to hold a keymap for all keys on the keyboard. 
* Created CommandRepository which holds a smart pointer to each Command needed in the game. The input class holds an instance of CommandRepository to assign pointers to its keymap.
* Created NullCommand as per the Null Object pattern.
* Moved Input to Engine, so there is a single instance. It is injected into EngineStates.
* Moved mouse looking control out of ActorComponent::message() and into look(). The MouseMove Command calls look().
* Added getActorComponent() to Entity since the actor component needs to be retrieve so many times. This is messy IMO but a good decision to avoid repeating myself.
* It seems that NVIDIA doesn't know how to compile for the current visual studio version...I used the .sln file for the extensions library after changing the Runtime Library option in C/C++ -> Code Generation to /MDd which was previously /MTd. The new .lib file works.

== 2/7/15 ==
* Created Physics class, which is part of Engine. It initializes the base PhysX objects: PxFoundation and PxPhysics. It is passed into PScene:
* Created PScene class, which is part of World. It contains a PxScene which holds data for a single scene of physics simulation.
* Made a simple PxRigidDynamic test in IntroState, applied it to the Ogre mesh. I believe I have the simulate() correct on the physx scene, at 1.f / 16.f (16. is the MS_PER_UPDATE in Engine).
* Got a sample sphere rigid dynamic actor to roll off a static box actor. Next I must integrate this code into components.

== 2/8/15 ==
* Added loadMeshes() in Resources.cpp, which is called after loadOgreResources() in Engine::init(). For now it just creates a mesh in memory to be used for a plane.
* Created PhysicsComponent, which holds either a static or dynamic PhysX actor.
* Modified Component initialization to use an overloaded init() function rather than one or more set*() functions. This minimizes the setup code for Entities(however still large, should be moved to factory functions).
* Also modified the attach*() functions for Components to take the proper Component rather than the internal data (such as Ogre::Camera etc.); it is all done internally within the Component.
* Added several wrapper functions for PhysicsComponent to modify the Entity's location and rotation. rotate() however does not affect the PhysX transform and I don't know why.
* Tested both a static plane and dynamic sphere using the PhysicsComponent. Tested rotating the plane with quaternion black voodoo magic to a 45 degree angle with success. 
* Added the PhysX kinematic character controller to ActorComponent. This also required a controller manager to be setup in the PScene. Got a simple movement system working, it will take much more experimentation and work to get it right. 

== 2/9/15 ==
* After a considerably long time of experimentation, I've converted the PhysX units to a 1 unit = 1 meter scale.
* Fixed pause when changing directions while moving.
* Created KCC (Kinematic Character Controller) class to encapsulate PhysX controller. The ActorComponent allocates it. Also made DCC(Dynamic ..) which will be implemented at a later time.
* Fixed player movement to move at the same speed regardless of the camera's pitch.
* Added DynamicRenderable class from Ogre3D website.
* Added DynamicLines class for drawing debug lines or for any need of line drawing.
* Added ability for DynamicLines to translate, each instance has an origin vector3 which specifies the starting offset of the points.
* Created my own debug drawer for PhysX - PDebugDrawer. It takes PxRigidActor and PxGeometry as parameters and adds them to a list of debug nodes, each of which contain a DynamicLines instance 
    representing the actor's geometry. It can be enabled by calling PScene::loadDebugDrawer().
* I've changed the convention for Entities: instead of calling Entity::init() after all Components are attached, Component::init() should be called on every Component before it's attached. This prevents
    any nullptrs when Components need each other's data. Then, World::checkEntities() is called after scene creation, which checks if every Component attached to every Entity has been initialized. 
* Put in about 10 hours today.

== 2/10/15 ==
* Not much time to work today :(
* Added default material to PScene which is used by PhysicsComponent.
* Renamed MouseMoveCommand to LookCommand. This makes more sense for Actors being controlled by AI.

== 2/11/15 ==
* Changed Component's name string to an enum type for faster run-time checking.
* Added LightComponent, created point light as test.
* Replaced ComponentPool with Pool, which uses proper template instantiation in the cpp file, reducing compile times.
* Added SpectatorCommand to switch player into spectator mode temporarily while holding down a key (space at the moment).

== 2/12/15 ==
* Unsuccessfully tried to integrate Havok physics, but could not compile with visual studio 2013 as the free binaries were only 2012. If I am to use Havok, I'll have to obtain a license...when I have 40k+.
* Changed header of every file to GPL v3.0. Added LICENSE and README.md, uploaded to Github.

== 2/13/15 ==
* Added World::setFog(). 
* Replaced all tabs with 4 spaces. Changed visual studio to insert spaces for tabs.
* Added Entity::linkComponents() which detects what components are attached, such as scene and model components, and then attaches the model component to the scene, for example. This reduces the
    code needed to create an Entity. In World::checkEntities, every Entity's components will be linked if they are not in Entity::checkComponents().
* Compiled Hydrax plugin to work with Ogre 1.9. Note that several changes were required in the code (listed here http://www.ogre3d.org/addonforums/viewtopic.php?f=20&t=11089), and the debug build
    must be linked to OgreMain_d.lib to be compatible with the debug build for Talos.
* Had to set the shader mode for Hydrax to CG to work with OpenGL. GLSL is not implemented for it completely.
* Hydrax runs absurdly slow in debug mode, so I've prepared the release build. Had to rebuild CEGUI into release, PhysX extended in release.
* Physx threw a compile error about NDEBUG or _DEBUG being defined. Since NDEBUG has to do with asserts, I move my Assert.hpp include to the top of stdafx.hpp and defined NDEBUG after. 
* Having a problem with the edges of Hydrax water being clipped when the camera turns, tried creating a new camera for Hydrax and updating its position directly from the player to no avail.
* Turns out I had to use the cameras yaw and pitch nodes since the roll node wasn't being updated in ActorComponent::look().

== 2/14/15 ==
* Accidently set the near clip distance on the hydrax camera to 0.01f during encapsulation which caused the ocean to flicker on movement.
* Created Environment class, which is held in World. Environment holds functions for changing lighting and fog which were moved out of World. All visual properties of the scene should go here.
* Environment also has the new Ocean class which encapsulates Hydrax as of now. Ocean is updated each frame from World::update() -> Environment::update() -> Ocean::update().
* Created GraphicsSettings.hpp to store global graphics settings.
* Artifacts at edge of water was caused by lack of anti-aliasing. I've enabled 16x FSAA and it's gone.

== 2/15/15 ==
* Messed with some per-pixel lighting attempts, but I'll save that for later optimization after networking is in place.
* Created Sky class which is held in Environment, compiled SkyX Ogre plugin, added it to the Sky class.
* Got SkyX crudely working.
* Experiencing a bug where the entire viewport is white underwater.
* Was caused by setting the colour of hydrax's sun directly from getting Environment::m_sun's diffuse colour. I've just removed it.
* Have a basic day/night cycle.
* Added an EntityPtr to World which points to the player's entity. This is useful for the Ocean setup and will be useful in the future. 
* (Officially 2/16, but whatever) Rebuilding Ogre to support D3D9 because D3D11 support is utter garbage.
* Rebuilt latest Ogre with D3D9 support, I may have to rebuild CEGUI and Hydrax/SkyX with the rebuilt version of Ogre, not sure.
* Using D3D9 fixed the underwater issues, except the underwater compositor still ticks way faster than it should.
* Still no above water reflections even though everything is setup as it should be.

== 2/16/15 ==
* By not loading the Hydrax config file, reflections are enabled. So something in the .hdx file is disabling them.
* Compiled latest community Hydrax source, testing.
* It seems setting <float>GlobalTransparency=0.5 enabled reflection along with everything else working fine.
* Reflections are working but SkyX doesn't seem to support full sky reflection, as seen in the demo.
* Removing the frame listener for SkyX and instead calling SkyX::notifyCameraRender() now renders SkyX reflections in the ocean!
* Fixed artifacts in sky by explicitly setting the Player camera's clipping distance to 0.f -- infinite.
* Hydrax reflections in NM_VERTEX may be reversed, NM_RTT is probably the best way to go.
* Only remaining Hydrax bugs: Underwater compositor is too fast, the edges underwater have a gap that can be seen through.
* Made Ocean an interface, created OceanHighGraphics which uses the Ocean interface. This vastly reduces the conditional branching in its functions.
* Made Sky an interface, created SkyHighGraphics for SkyX. Same idea as Ocean and OceanHighGraphics. Interfaces are nice.
* Moved day/night lighting logic out of Environment::update() into SkyHighGraphics::update().
* As of now I use a hack to hide the sun underwater for Hydrax, but eventually the "sun" could be changed to the moon's colour and corresponding light strength for more realism.
* (now 2/17):
* Added SkyPreset struct, and SkyHighGraphics can now load some presets for thunderstorms etc.
* SkyX lightning seems to have a bug; it only appears directly above the camera (which is very bad looking). A hack is to add 100 to the position in the vertex shader (SkyX_Lightning.hlsl), 
    which makes the lightning appear above the clouds, but no more lightning bolts.
* So nevermind that hack. SkyX also has problems with cameras attached to scene nodes like HydraX. I've created a camera just for SkyX updates in SkyHighGraphics, and lightning is as it should be!
* Using two cameras caused reflection issues with Hydrax. So if I want to use lightning Hydrax will be out of the question unless I find a way to fix it. 
    One workaround would be to add another cloud layer below the player and above Hydrax, and change the preset to not use lightning and reassign the camera pointer when Hydrax is seen.

== 2/18/15 ==
* Added proper cleanup code to Environment::destroy() for sky.
* Fixed the lightning position bug in SkyX. The calculation for where to place the lightning was using the camera's position plus its far clip distance, which in my case is 0.f, so it was 
    always positioned directly above the camera.
    The fix is simple, change the section of code in LightningManager.cpp that adds lightning to this (line 119 to 174):
                // Select a random camera to place the lightning
				if (!mVClouds->_getCamerasData().empty())
				{
					Ogre::Camera* c = mVClouds->_getCamerasData().at(mVClouds->_getCamerasData().size()*0.999).camera;
                    Ogre::Real farClipDist = c->getFarClipDistance();
                    if (farClipDist == 0.f){
                        // Infinite far clip distance, assign a random value.
                        farClipDist = Ogre::Math::RangeRandom(1.f, 99999.f * 6.f);
                    }

					Ogre::Real prob = Ogre::Math::RangeRandom(0,1);
                   
					// Cloud-to-ground
					if (prob < 0.5)
					{
						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(0,-1,0), 
							// Ray length
							mVClouds->getGeometrySettings().Height.x + 0.1*mVClouds->getGeometrySettings().Height.y);
					}
					// Cloud-to-cloud
					else if (prob < 0.7)
					{
						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(Ogre::Math::RangeRandom(-1,1),Ogre::Math::RangeRandom(-0.1,0.1),Ogre::Math::RangeRandom(-1,1)).normalisedCopy(), 
							// Ray length
							Ogre::Math::RangeRandom(0.5,1.5f)*0.2*mVClouds->getGeometrySettings().Height.y);
					}
					// Cloud-to-ground + cloud-to-cloud
					else
					{
						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(0,-1,0), 
							// Ray length
							mVClouds->getGeometrySettings().Height.x + 0.1*mVClouds->getGeometrySettings().Height.y);

						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(Ogre::Math::RangeRandom(-1,1),Ogre::Math::RangeRandom(-0.1,0.1),Ogre::Math::RangeRandom(-1,1)).normalisedCopy(), 
							// Ray length
							Ogre::Math::RangeRandom(0.5,1.5f)*0.2*mVClouds->getGeometrySettings().Height.y);
					}

					updateMaterial();
				}

* I've temporarily added SkyX source directly into my project for debugging, it'll be removed for any production build.
* Added LightningManager.cpp to the repo for record keeping.
* Modified Entity system for more efficiency. Before it had getComponentPtr() which was slow and searched through the linked list of attached components. 
    Now there is an array based list (STL vector) of components which I call the component registry; it allocated enough space for all possible components. When a component is attached,
    its corresponding slot for its ID is set to point to the newly attached component, and additionally the new component pointer is added to the linked list I call "m_activeComponents".
    This changes retrieving a component pointer from an entity from O(n) to O(1) complexity at little cost of additional code.
* Component-specific getter functions have been added to Entity for each component(e.g., Entity::getCameraComponent(), Entity::getModelComponent(), etc.).
* Added ComponentDecls.hpp which forward declares all the Component types and the typedefs for pointers to them. This reduces repetition in header files.
* Added OceanLowGraphics using ocean shader from the Ogre samples, tested in debug mode.

== 2/20/15 ==
* Added Talos::Config class for basic ini parsing.
* Created Server class (compiled latest RakNet as well).
* Experienced a really strange bug where World::getPlayer() returned nullptr even after the player pointer was set(clearly seen within debugger). This occurred after adding Server and Client to
    the World::Dependencies struct, but forgetting to apply the pointers in World::injectDependencies(). After applying them in World.hpp the bug no longer occurred. Moved World::injectDependences()
    into World.cpp, then commented out the code that assigns the server and client pointers, and the bug still didn't occur. I don't know what caused this so for the record it's an unsolved bug.
* I fear the World class is slowly becoming a god object.
* Created Client class. Tested basic connection to server successfully.
* Engine holds a shared_ptr to both a Server and Client object. These are injected into the World of each engine state, so that each state can access them as needed.
* Server and Client are initialized using World::initServer() and World::initClient(). World::update() calls update on the Server or Client if one is registered.
* In using the RakNet::BitStream I accidently used and std::string which gets corrupted over the wire, you must use RakNet::RakString. 
* Created a Serialize() function for a test struct in Client for sending from the client to the server. All network data structures will need to be placed in one file.

== 2/22/15 ==
* Added EngineNotifications.hpp and EngineStateID.hpp to allow non-coupled access to engine states and notification enumerations from game states.
* Added StartupState which creates a thread to load resources, it checks a bool to determine if all resources have been loaded and then notifies the engine to pop its state and push 
    the main menu state.
* Experiencing a total freeze during StartupState after loadMeshes(), also before it. I think this is a race condition within the Ogre/CEGUI systems, since in Engine::start() their rendering
    systems are being updated and at the same time resources are being loaded. A threaded approach may be more trouble than it's worth here.
   Note that this freeze bug is difficult to reproduce; it takes several runs at the very least to see it again.
   CEGUI::..injectTimePulse() could be the cause.

== 2/23/15 ==
* Re-designed Entity-component layout yet again. Now Entity holds a hash table of Components, and it uses RTTI (typeid) to statically determine Component types when retrieving them using a
    template function.
* Added Component::onComponentAttached() which is called for every attached component on an entity if a new component is attached. This functions as a listener in which components can
    wire up needed data between each other, such as SceneComponent's scene node to ModelComponent's Ogre::Entity.
* Prior two changes remove the need for Component::Type and Entity::linkComponents().

== 2/24/15 ==
* Created MainMenuState, removed IntroState.
* Made basic main menu CEGUI layout file. It is not resolution-independent however.
* Changed World to hold an Ogre::Camera rather than Entity for Ocean/Sky's needs.
* Added UI interface class, created MainMenuUI. EngineState holds a smart pointer to UI, which must be allocated and initialized within the derived states as needed.
* Manually editing the .layout file is easier than using the CEED editor. I've got unified dimensions working well; the GUI looks fine on multiple resolutions.

== 2/25/15 ==
* Added UI layer stack system to UI class.
* Added World::attachComponent<T>(), which is specialized for each type of component. This reduces component initialization and attaching to one line for basic setup. Any additional settings
    will require getting the component pointer until I can figure out how to return the T* pointer for each type (would require substantial redesign of component pools).
* Added pause() and resume() to EngineState.
* Created LobbyState which is pushed when the user hosts a game (in the future joining a game will do the same).

== 2/27/15 ==
* Upon popping the LobbyState, the MainMenuState would render CEGUI incorrectly; the mouse arrow would accumulate endlessly forming a trail, the windows were not applying alpha values. This was
    caused by destroying the scene manager in World upon popping the state. Furthermore this was caused by destroying the camera associated with the viewport in the LobbyState. By not destroying
    the camera, everything is fine, since the menu state was still trying to render the viewport using lobby state's camera. I've added World::resume() which assigns the World's main camera
    to the viewport, and should be called when resuming any state.
* Made UI::update() non-pure, it calls injectTimePulse on CEGUI's System and returns true if there are queued events. Derived UIs currently just call the super function.

== 2/28/15 ==
* Added Talos::Log singleton class. This is the first singleton and probably the last.
* Created UIEvent struct (defined in UI.hpp) which is queued in UI when events that need processing occur. The state holding the UI can access the UIEvents and their data as needed.
* Removed World::m_useServer and m_useClient and just put a m_initialized bool inside Server and Client for efficiency. This is also needed so LobbyState can close network connections upon exit.
* Added a hash table for connected clients in Server, had to implement a custom hash function for RakNet::RakNetGUID since I want to store clients by their unique GUIDs. The hash function simply
    uses the GUID since they are unique.
* Enabled user to specify username and port when hosting game.
* Reworked how Server/Client initialization is handled. Created abstract base class Network which Server and Client derive from. Network provides mostly interface functions but a few important ones as well.
    Now to update/access the server or client service, it can be done directly through the World::Network pointer, which is assigned to the Server or Client when they are initialized.
* Added Server broadcasting.
* Added chat service.

== 3/1/15 ==
* Server now sends clients player list upon connection. 
* Got disconnection notifications working, except only with LOST_CONNECTION, it won't send a notification immediately.
* When disconnecting the client creates a thread to wait for RakNet to send out the disconnection notification.
    When the thread is complete, m_connected is set to false. Initializing or connecting is not possible if m_connected is true.
* Added UI::setUsername() so the user sees their own username when sending a chat message.
* (3/2/15) Added server broadcasting of client disconnections. Each client is just sent the player list again.
* Changed client to use a hash table for player list instead of vector as before.

== 3/4/15 ==
* Added GameState.
* Changed Input key map to use a hash table.
* Fix World::attachComponent<T> to return the pointer to the newly created Component, using additional template specialization (a struct with a typedef that is
	also specialized). attachComponent<T> now returns componentReturn<T>::type, which is T*.
* Added abstract System class, which holds a hash table of Entities who have related components (such as SceneComponent and PhysicsComponent). Any per-frame
	updates are done in the System::update() function in derived classes. 
* Tested System with PhysicsSystem for updating scene nodes transforms from the physics engine. Temporarily have it in GameState, but some kind of System container
	will go in World.
* Removed Component's need for Entity, reduced coupling.
* (3/5/15) Created ComponentFactory which remove the need for holding all the component pools in World and delegates them to a factory class. World now calls into ComponentFactory from
    attachComponent<T>.
* Added SystemManager which holds a hash table of System objects. It has been added to World, which has the helper function addSystem() which calls into SystemManager.

== 3/5/15 ==
* Changed Entity::checkComponents() to setupComponents() - it calls Component::onComponentAttached() for every component attached, passing in every component that's attached. This makes it so
    the order in which components are attached to an Entity does not matter, so long as Entity::setupComponents() is called once all components are attached. This is automated through 
    World::setupEntities().
    So to manually create a new Entity without using World::setupEntities(), one could add the components like normal, then call Entity::setupComponents() directly, and World::addEntityToSystem().
* Added Talos.hpp/cpp which defines MS_PER_UPDATE (16.0 for now) and the version major and minor values for engine.

== 3/6/16 ==
* Changed PhysicsComponent to store the EntityID in the PhysX actor's user data rather than the EntityPtr itself.
* Added a hash table into World that stores EntityIDs and EntityPtrs, so looking up an Entity by its ID is O(1). A little extra overhead but worth it for raycasting PhysX actors.
* Added Typedefs.hpp to Source directory, which forward declares most classes and several typedefs. Anything that must be forward declared in a header file more than once should go here.
* Added World::handleInput() to reduce pointer chasing in engine states.
* Added NullNetwork, which is a null object of the abstract Network class. There is a static instance in World.cpp which is assigned to World::m_network when neither the client nor server are
    active. This removes the need for null guarding in engine states.
* Added basic game starting and ending for multiplayer.
* Removed Ogre::Camera pointer from ActorComponent. Now the translation vector per frame is modified to maintain the same velocity regardless of pitch using the roll nodes derived orientation.
* Added Network::getNumPlayers() and Network::addPlayerEntity(). In GameState::enter(), an entity is created for each player and added to the server.

== 3/7/16 ==
* Changed CommandRepository to use a hash table for storing CommandPtr objects.
* (3/8/16) Added CommandType.hpp which enumerates the strongly typed CommandType. Now Command has a member CommandType, for use as a key in CommandRepository's hash table.
    Note this is only for networking code--to identify which type of command the client sent without needing serialization. Serialization of the entire Command objects seems like a waste of
    bandwidth, but if I have extra time I will see if it can be implemented. Or perhaps the RakNet RPC4 plugin would be useful for this.
* Got basic client movement working with server. 

== 3/9/16 ==
* Note that the error C2440: 'static_cast' : cannot convert from 'Component *' to 'xxxComponent *' when calling Entity::getComponent<T> is caused by not including the header associated with 
    that component.
* Added CollisionComponent, which separates the extra clutter from PhysicsComponent for managing both static and dynamic PhysX actors. CollisionComponents are for static actors, while 
    PhysicsComponents are for dynamic actors. 
* PhysX objects are now added by getting the Ogre3D bounding box (for box shapes), so no needed to specify sizes manually anymore.
* Added CollisionSystem to deal with CollisionComponent/SceneComponent pairs.
* Added some basic static conversion functions to Physics class.
* Changed ComponentMessage to use boost::variant instead of union, so it can store classes inside of a union-like data structure, for saving memory when sending component messages.
* It's now possible to translate a scene component by sending it a message.
* Moved all linking together of components into SystemManager::processEntity(). There is no longer a need for Entity::setupComponents().
* Added proper (at least visually) gravity for free fall.
* Added jumping ability for KCC.
* Created PScene::raycast() which uses the PScene::Ray struct.
* Fixed server player updates sent to clients. 

== 3/10/16 ==
* Fixed client/server player updates. It scales to multiple clients now.
* Removed the typedefs for the hash tables of players in Client and Server, and put it in Network. Now Network has an instance of the table to store every player, and it also has a pointer
    to the local player instance. All server/client operations should use the single Network instance through its helper functions.
* Server contains an additional table with a GUID->NetworkID key pair (m_clients). It can lookup a network ID from the GUID in a packet and get the Network::Player instance it needs.
* GameState now retrieves the list of network players and iterates through them manually, adding entity pointers to each null instance. Both server and client set all entity pointers back to 
    nullptr when ending the game.
* Added toString() and toRakString() in Network for cleaner conversions.
* Changed mouse input to not use a command, rather there is the function Input::handleMouse() which returns a MouseMove struct, which has relative x & y movement. This can then be used to 
    message the player entity move the camera using the "Look" message.
    This makes it so I don't have to send "released" events from the client to the server, by setting the actor component's movement values to false each frame in its update function.

== 3/14/16 ==
* Changed Command's execute() functions to send messages to the entity rather than accessing components directly (except spectator, which is temporary).
* Made NetEvent use boost::variant, Server now notifies engine state of player updates, which the game state then retrieves the entity from the world using the		
	entity ID saved in the TransformUpdate struct by the Server.
* Removed ActorComponent's setMovingForward() etc. and it is now handled with messaging.
* Added NetworkComponent for client-side prediction. Doesn't work yet, jumps around too much.

== 3/15/16 ==
* Fixed client-side prediction--the input processing needed to be changed. Rather than setting bit values when the movement keys are pressed, the actor should just be translated immediately,
    which eliminates the problem of the server not moving the client's actor the frame after receiving a move command, since the bit values were being reset.
* The above re-introduced the problem of moving faster when going diagonal, since the normalised vector is just the movement vector for one direction and not both.

== TODO ==
* Move input update into world.
* Change UI/Net events to use boost::variant.
* Add ability to specify box half extents directly in collision objects for invisible walls and such.
* Add PhysX mesh (cooking) collision volumes for models.
* Popup error box when trying to connect while previous connection is being closed.
* Client should test timestamp of update packets to ensure no out of order updates.
* Create EventQueue system to deal with network and UI. Pass World into network classes and have something like World::handleNetworkEvent().
* SkyLowGraphics.
* Consider creating a function in World to handle input for Client so it can be sent to the server.
* Shift input for sprint.
* Create a SkyX config file.
* Add a "clock speed" variable to the World, should affect physics etc.
* ActorComponent could use some redesign - CameraComponent is completely unnecessary, and AIComponent will be redundant.
* Put character controller data into config file to speed up testing.
* Make PhysX use software mode if NVIDIA card is not detected.
* Enums appear to be at random places in class definitions, make them consistent.
* Have a pointer to an EntityFactor in World? (For creating specific Entities such as box, enemy, etc.)
* Have all classes that shouldn't be derived from be declared as final.
* Put an EntityRegistry in World which has an associative array of IDs to strings for Entity names.
* Make sure Entities are destroyed properly when World is destroyed.
* Alphabetize includes everywhere. Folder name is first if in a folder.
* Implement config file loading for options in Engine::init() and others.
* Refer to http://gameprogrammingpatterns.com/event-queue.html for Audio.

== BUGS ==
* Moving diagonally is faster, due to changes in input system. Fix in KCC or ActorComponent.
* Casting ray upwards with PhysX (PScene::raycast()) still returns a result if no hit.
* Raycast doesn't hit dynamic actor.
* Hydrax/SkyX need to be shared between states--make them world dependencies perhaps and add code to check if they are already initialized.
* When client reconnects, a third client that was still connected can send a chat and the reconnected client will display the chat from their own username.
* CEGUI disappears when resizing window.
** Hydrax underwater is sped up, fix. (E:\Engine\Ogre3D\Hydrax-v0.5.1\Hydrax\Hydrax.vcproj to recompile).

