A log of all work done on engine.

== 1/19/15 - 1/26/15 ==
* Read "Game Programming Patterns" by Robert Nystrom in hopes to build a strong design background before starting.

== 1/26/15 ==
'''Prepared for building a consolidated engine.'''
* Built Ogre3D dependencies--FreeImage, FreeType, zlib, and zziplib.
* Built Ogre3D(1.9.0) binaries from latest source.
* Applied for NVIDIA GameWorks to acquire PhysX SDK, then downloaded Core PhysX SDK(3.3.2).
* Built RakNet(4.081) binaries.
* Built CEGUI(0.8.4) binaries (getting CMake to work for this was a little tricky).
* Acquired irrKlang(1.5.0) SDK.
* Acquired SDL2(2.0.3) development libraries.
'''---'''
* Created Visual Studio 12.0 solution. Added main.cpp, compiled and linked with Ogre3D and Boost successfully.
* Created Engine class, which initializes Ogre and will manage the engine states (menu, game, pause, etc.).
* Added stdafx.hpp.
* Added EngineState class, which is abstract; derived classes represent a single state that can be active at a time. The IntroState has been created as a test.
* Added EngineState::injectDependencies() which as of now takes pointers to Ogre::Root and Ogre::Viewport initialized by Engine. This can be later expanded to take a struct or perhaps generics. The prevents me from having to use Engine as a singleton by giving each EngineState the objects they need.
* Tested basic game loop updating and active state updating.

== 1/27/15 ==
* Added Engine::registerState(). This should be called in for each state that will be needed during initialization.
* Added Assert(exp, desc) macro, which tests an expression for true and offers the option to break into the debugger if the expression is false. A description is also supplemented for each Assert.
* Added HelperFunctions.hpp which for now contains a generic toString() function for converting just about anything to std::string.
* Tried to add a basic mesh and a prefab cube and render it with Direct3D11, however errors were occurring which probably had to do with the shaders I'm using or a bug in the engine. Apparently, Direct3D11 support is not even fully implemented yet, so I may have to use the OpenGL rendering system for the duration of this project.
* OpenGL shaders working on a basic mesh.
* Implemented a game loop that uses a fixed time step when updating the state but adjusts for lost time during the rendering phase. Once physics support has been added, it should be "free" and hence the game world will be deterministic.
* Researched some Entity-component system implementations. Everyone seems to have their own way of doing it, so I'll just have to try it. One of my main goals is to store the components in contiguous memory to optimize cache hits.

== 1/28/15 ==
* Created base Component and Entity classes. These are abstract; Component can be derived from into a chain (e.g., Component <- InputComponent <- DemoInputComponent) and Entity should only be derived from once per entity (e.g., Entity <- Player, Entity <- Elevator, Entity <- Gun).
* Created SceneComponent which holds an Ogre::SceneNode to hold the transform in the game world.
* Made System interface. Each type of component should have its own system (e.g., PhysicsSystem, SceneSystem, ModelSystem, etc.).
* Created World class which will hold all data for the game world. Each EngineState has one.
* Created CameraComponent.
* Created Player class derived from Entity. Added a SceneComponent and CameraComponent. Tested for rendering successfully.

== 1/29/25 ==
* Modified Entity class to have init(), destroy(), and update() functions implemented. All of these simply traverse the list of Components stored in the Entity. 
* Component now has pure virtual methods init(), destroy(), update(), all of which take EntityPtr and World& parameters.
* Added SceneComponent::attachObject() which takes an Ogre::MovableObject* and attaches it to the internal Ogre::SceneNode*.
* Created EntityPool class, which has O(1) creation time when retrieving the next available Entity from the contiguous array.
* Delegated Entity creation to the World class, which holds an EntityPool and calls upon it internally.
* Decoupled SceneComponent from CameraComponent::init(). Use CameraComponent::getCamera() and pass it into SceneComponent::attachObject().
* Added FirstPersonComponent which sets up a system of nodes that control a first person camera.
* Added SDL2 and associated the SDL window with the window created by Ogre. 
* Added Message struct in Component folder. Also enums for message types.
* Tested input with SDL, setup mouse motion event to move camera.

== 1/30/15 ==
* Added Entity::message() which broadcasts a message to all attached components.
* Created InputComponent which detects input and sends a corresponding message to the parent Entity.
* Added pitch limitation in FirstPersonComponent, so the camera can't be pitched to an upside down state.
* Made World a friend class of EntityPool, added World::update() which iterates through the EntityPool and calls update on each Entity.

== 1/31/15 ==
* Created ComponentPool generic class. 
* Added ComponentPool instances to World for each type of Component. This increases coupling here but Component creation can be confined to the World class rather than allowing dynamic allocation on the fly.
* Tested an Entity with an ogrehead.mesh ModelComponent. It rotates at the same rate regardless of frame rate, so my update architecture is indeed frame rate indepedent. Just the mouse relative coordinates depend on the frame time.

== 2/2/15 ==
* Removed EngineState::injectDepedencies and created World::injecteDependencies. It's called in Engine::registerState().
* Added World::Dependencies struct for easy parameter passing and change if needed.
* Started integrating CEGUI. Turns out after compiling CEGUi it generated three headers (Config.h, ModuleConfig.h, and Version.h) which should be copied to the main include directory for CEGUI.
* Got a basic CEGUI window setup inside the viewport.
* Synced the CEGUI mouse position using GUIContext::injectMousePosition().
* Removed window creation from Ogre and let SDL create the window. This way, I have more control over mouse behavior without having to resort to Win32 API. So I can now lock the mouse at the center for camera movement. It can be
	disable for using the GUI. After the SDL_Window is created, Ogre calls Root::createRenderWindow() using a window handle parameter retrieved from the SDL_Window. 
	The call to CEGUI::OgreRenderer::bootstrapSystem() also needs a dereferenced Root::getRenderTarget("window name") for initialization.
* Added Input class which takes SDL events and handles them, for player input and GUI input.
* Removed InputComponent as the new Input class takes over. 

== 2/3/15 ==
* Added Observer and Subject classes. 
* Made Engine derive from Observer; it receives notifications from EngineStates. So if it receives a "POP" notification from the active state, it will pop that state.

== TODO ==
* Add Null object pattern to Input.
* Add System classes for all components to live in. Factory functions in World should create them.
* Alphabetize includes everywhere. Folder name is first if in a folder.
* Make Entity final? Still not sure if I should allow subclassing for convenience. Entities could be data-driven?
* Mouse camera movement is frame rate dependent.
* Change std::string id system for components to an enum int system to save memory and CPU cycles.
* Implement config file loading for options in Engine::init() and others.