// ========================================================================= //
// Talos - A 3D game engine with network multiplayer.
// Copyright(C) 2015 Jordan Sparks <unixunited@live.com>
//
// This program is free software; you can redistribute it and / or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
// ========================================================================= //
// File: work-log.txt
// Author: Jordan Sparks <unixunited@live.com>
// ========================================================================= //
// A log of all work done on the program.
// ========================================================================= //

== 1/19/15 - 1/26/15 ==
* Read "Game Programming Patterns" by Robert Nystrom in hopes to build a strong design background before starting.

== 1/26/15 ==
'''Prepared for building a consolidated engine.'''
* Built Ogre3D dependencies--FreeImage, FreeType, zlib, and zziplib.
* Built Ogre3D(1.9.0) binaries from latest source.
* Applied for NVIDIA GameWorks to acquire PhysX SDK, then downloaded Core PhysX SDK(3.3.2).
* Built RakNet(4.081) binaries.
* Built CEGUI(0.8.4) binaries (getting CMake to work for this was a little tricky).
* Acquired irrKlang(1.5.0) SDK.
* Acquired SDL2(2.0.3) development libraries.
'''---'''
* Created Visual Studio 12.0 solution. Added main.cpp, compiled and linked with Ogre3D and Boost successfully.
* Created Engine class, which initializes Ogre and will manage the engine states (menu, game, pause, etc.).
* Added stdafx.hpp.
* Added EngineState class, which is abstract; derived classes represent a single state that can be active at a time. The IntroState has been created as a test.
* Added EngineState::injectDependencies() which as of now takes pointers to Ogre::Root and Ogre::Viewport initialized by Engine. This can be later expanded to take a struct or perhaps generics. The prevents me from having to use Engine as a singleton by giving each EngineState the objects they need.
* Tested basic game loop updating and active state updating.

== 1/27/15 ==
* Added Engine::registerState(). This should be called in for each state that will be needed during initialization.
* Added Assert(exp, desc) macro, which tests an expression for true and offers the option to break into the debugger if the expression is false. A description is also supplemented for each Assert.
* Added HelperFunctions.hpp which for now contains a generic toString() function for converting just about anything to std::string.
* Tried to add a basic mesh and a prefab cube and render it with Direct3D11, however errors were occurring which probably had to do with the shaders I'm using or a bug in the engine. Apparently, Direct3D11 support is not even fully implemented yet, so I may have to use the OpenGL rendering system for the duration of this project.
* OpenGL shaders working on a basic mesh.
* Implemented a game loop that uses a fixed time step when updating the state but adjusts for lost time during the rendering phase. Once physics support has been added, it should be "free" and hence the game world will be deterministic.
* Researched some Entity-component system implementations. Everyone seems to have their own way of doing it, so I'll just have to try it. One of my main goals is to store the components in contiguous memory to optimize cache hits.

== 1/28/15 ==
* Created base Component and Entity classes. These are abstract; Component can be derived from into a chain (e.g., Component <- InputComponent <- DemoInputComponent) and Entity should only be derived from once per entity (e.g., Entity <- Player, Entity <- Elevator, Entity <- Gun).
* Created SceneComponent which holds an Ogre::SceneNode to hold the transform in the game world.
* Made System interface. Each type of component should have its own system (e.g., PhysicsSystem, SceneSystem, ModelSystem, etc.).
* Created World class which will hold all data for the game world. Each EngineState has one.
* Created CameraComponent.
* Created Player class derived from Entity. Added a SceneComponent and CameraComponent. Tested for rendering successfully.

== 1/29/25 ==
* Modified Entity class to have init(), destroy(), and update() functions implemented. All of these simply traverse the list of Components stored in the Entity. 
* Component now has pure virtual methods init(), destroy(), update(), all of which take EntityPtr and World& parameters.
* Added SceneComponent::attachObject() which takes an Ogre::MovableObject* and attaches it to the internal Ogre::SceneNode*.
* Created EntityPool class, which has O(1) creation time when retrieving the next available Entity from the contiguous array.
* Delegated Entity creation to the World class, which holds an EntityPool and calls upon it internally.
* Decoupled SceneComponent from CameraComponent::init(). Use CameraComponent::getCamera() and pass it into SceneComponent::attachObject().
* Added FirstPersonComponent which sets up a system of nodes that control a first person camera.
* Added SDL2 and associated the SDL window with the window created by Ogre. 
* Added Message struct in Component folder. Also enums for message types.
* Tested input with SDL, setup mouse motion event to move camera.

== 1/30/15 ==
* Added Entity::message() which broadcasts a message to all attached components.
* Created InputComponent which detects input and sends a corresponding message to the parent Entity.
* Added pitch limitation in FirstPersonComponent, so the camera can't be pitched to an upside down state.
* Made World a friend class of EntityPool, added World::update() which iterates through the EntityPool and calls update on each Entity.

== 1/31/15 ==
* Created ComponentPool generic class. 
* Added ComponentPool instances to World for each type of Component. This increases coupling here but Component creation can be confined to the World class rather than allowing dynamic allocation on the fly.
* Tested an Entity with an ogrehead.mesh ModelComponent. It rotates at the same rate regardless of frame rate, so my update architecture is indeed frame rate indepedent. Just the mouse relative coordinates depend on the frame time.

== 2/2/15 ==
* Removed EngineState::injectDepedencies and created World::injecteDependencies. It's called in Engine::registerState().
* Added World::Dependencies struct for easy parameter passing and change if needed.
* Started integrating CEGUI. Turns out after compiling CEGUi it generated three headers (Config.h, ModuleConfig.h, and Version.h) which should be copied to the main include directory for CEGUI.
* Got a basic CEGUI window setup inside the viewport.
* Synced the CEGUI mouse position using GUIContext::injectMousePosition().
* Removed window creation from Ogre and let SDL create the window. This way, I have more control over mouse behavior without having to resort to Win32 API. So I can now lock the mouse at the center for camera movement. It can be
    disable for using the GUI. After the SDL_Window is created, Ogre calls Root::createRenderWindow() using a window handle parameter retrieved from the SDL_Window. 
    The call to CEGUI::OgreRenderer::bootstrapSystem() also needs a dereferenced Root::getRenderTarget("window name") for initialization.
* Added Input class which takes SDL events and handles them, for player input and GUI input.
* Removed InputComponent as the new Input class takes over. 

== 2/3/15 ==
* Added Observer and Subject classes. 
* Made Engine derive from Observer; it receives notifications from EngineStates. So if it receives a "POP" notification from the active state, it will pop that state.

== 2/6/15 ==
* Renamed FirstPersonComponent to ActorComponent, which can be used to control an Entity using either a player, AI, or network player (also replays).
* Added Command interface class. Command::execute() takes an EntityPtr and can retrieve the components it might need from that pointer.
* Added a std::map to the Input class to hold a keymap for all keys on the keyboard. 
* Created CommandRepository which holds a smart pointer to each Command needed in the game. The input class holds an instance of CommandRepository to assign pointers to its keymap.
* Created NullCommand as per the Null Object pattern.
* Moved Input to Engine, so there is a single instance. It is injected into EngineStates.
* Moved mouse looking control out of ActorComponent::message() and into look(). The MouseMove Command calls look().
* Added getActorComponent() to Entity since the actor component needs to be retrieve so many times. This is messy IMO but a good decision to avoid repeating myself.
* It seems that NVIDIA doesn't know how to compile for the current visual studio version...I used the .sln file for the extensions library after changing the Runtime Library option in C/C++ -> Code Generation to /MDd which was previously /MTd. The new .lib file works.

== 2/7/15 ==
* Created Physics class, which is part of Engine. It initializes the base PhysX objects: PxFoundation and PxPhysics. It is passed into PScene:
* Created PScene class, which is part of World. It contains a PxScene which holds data for a single scene of physics simulation.
* Made a simple PxRigidDynamic test in IntroState, applied it to the Ogre mesh. I believe I have the simulate() correct on the physx scene, at 1.f / 16.f (16. is the MS_PER_UPDATE in Engine).
* Got a sample sphere rigid dynamic actor to roll off a static box actor. Next I must integrate this code into components.

== 2/8/15 ==
* Added loadMeshes() in Resources.cpp, which is called after loadOgreResources() in Engine::init(). For now it just creates a mesh in memory to be used for a plane.
* Created PhysicsComponent, which holds either a static or dynamic PhysX actor.
* Modified Component initialization to use an overloaded init() function rather than one or more set*() functions. This minimizes the setup code for Entities(however still large, should be moved to factory functions).
* Also modified the attach*() functions for Components to take the proper Component rather than the internal data (such as Ogre::Camera etc.); it is all done internally within the Component.
* Added several wrapper functions for PhysicsComponent to modify the Entity's location and rotation. rotate() however does not affect the PhysX transform and I don't know why.
* Tested both a static plane and dynamic sphere using the PhysicsComponent. Tested rotating the plane with quaternion black voodoo magic to a 45 degree angle with success. 
* Added the PhysX kinematic character controller to ActorComponent. This also required a controller manager to be setup in the PScene. Got a simple movement system working, it will take much more experimentation and work to get it right. 

== 2/9/15 ==
* After a considerably long time of experimentation, I've converted the PhysX units to a 1 unit = 1 meter scale.
* Fixed pause when changing directions while moving.
* Created KCC (Kinematic Character Controller) class to encapsulate PhysX controller. The ActorComponent allocates it. Also made DCC(Dynamic ..) which will be implemented at a later time.
* Fixed player movement to move at the same speed regardless of the camera's pitch.
* Added DynamicRenderable class from Ogre3D website.
* Added DynamicLines class for drawing debug lines or for any need of line drawing.
* Added ability for DynamicLines to translate, each instance has an origin vector3 which specifies the starting offset of the points.
* Created my own debug drawer for PhysX - PDebugDrawer. It takes PxRigidActor and PxGeometry as parameters and adds them to a list of debug nodes, each of which contain a DynamicLines instance 
    representing the actor's geometry. It can be enabled by calling PScene::loadDebugDrawer().
* I've changed the convention for Entities: instead of calling Entity::init() after all Components are attached, Component::init() should be called on every Component before it's attached. This prevents
    any nullptrs when Components need each other's data. Then, World::checkEntities() is called after scene creation, which checks if every Component attached to every Entity has been initialized. 
* Put in about 10 hours today.

== 2/10/15 ==
* Not much time to work today :(
* Added default material to PScene which is used by PhysicsComponent.
* Renamed MouseMoveCommand to LookCommand. This makes more sense for Actors being controlled by AI.

== 2/11/15 ==
* Changed Component's name string to an enum type for faster run-time checking.
* Added LightComponent, created point light as test.
* Replaced ComponentPool with Pool, which uses proper template instantiation in the cpp file, reducing compile times.
* Added SpectatorCommand to switch player into spectator mode temporarily while holding down a key (space at the moment).

== 2/12/15 ==
* Unsuccessfully tried to integrate Havok physics, but could not compile with visual studio 2013 as the free binaries were only 2012. If I am to use Havok, I'll have to obtain a license...when I have 40k+.
* Changed header of every file to GPL v3.0. Added LICENSE and README.md, uploaded to Github.

== 2/13/15 ==
* Added World::setFog(). 
* Replaced all tabs with 4 spaces. Changed visual studio to insert spaces for tabs.
* Added Entity::linkComponents() which detects what components are attached, such as scene and model components, and then attaches the model component to the scene, for example. This reduces the
    code needed to create an Entity. In World::checkEntities, every Entity's components will be linked if they are not in Entity::checkComponents().
* Compiled Hydrax plugin to work with Ogre 1.9. Note that several changes were required in the code (listed here http://www.ogre3d.org/addonforums/viewtopic.php?f=20&t=11089), and the debug build
    must be linked to OgreMain_d.lib to be compatible with the debug build for Talos.
* Had to set the shader mode for Hydrax to CG to work with OpenGL. GLSL is not implemented for it completely.
* Hydrax runs absurdly slow in debug mode, so I've prepared the release build. Had to rebuild CEGUI into release, PhysX extended in release.
* Physx threw a compile error about NDEBUG or _DEBUG being defined. Since NDEBUG has to do with asserts, I move my Assert.hpp include to the top of stdafx.hpp and defined NDEBUG after. 
* Having a problem with the edges of Hydrax water being clipped when the camera turns, tried creating a new camera for Hydrax and updating its position directly from the player to no avail.
* Turns out I had to use the cameras yaw and pitch nodes since the roll node wasn't being updated in ActorComponent::look().

== 2/14/15 ==
* Accidently set the near clip distance on the hydrax camera to 0.01f during encapsulation which caused the ocean to flicker on movement.
* Created Environment class, which is held in World. Environment holds functions for changing lighting and fog which were moved out of World. All visual properties of the scene should go here.
* Environment also has the new Ocean class which encapsulates Hydrax as of now. Ocean is updated each frame from World::update() -> Environment::update() -> Ocean::update().
* Created GraphicsSettings.hpp to store global graphics settings.
* Artifacts at edge of water was caused by lack of anti-aliasing. I've enabled 16x FSAA and it's gone.

== 2/15/15 ==
* Messed with some per-pixel lighting attempts, but I'll save that for later optimization after networking is in place.
* Created Sky class which is held in Environment, compiled SkyX Ogre plugin, added it to the Sky class.
* Got SkyX crudely working.
* Experiencing a bug where the entire viewport is white underwater.
* Was caused by setting the colour of hydrax's sun directly from getting Environment::m_sun's diffuse colour. I've just removed it.
* Have a basic day/night cycle.
* Added an EntityPtr to World which points to the player's entity. This is useful for the Ocean setup and will be useful in the future. 
* (Officially 2/16, but whatever) Rebuilding Ogre to support D3D9 because D3D11 support is utter garbage.
* Rebuilt latest Ogre with D3D9 support, I may have to rebuild CEGUI and Hydrax/SkyX with the rebuilt version of Ogre, not sure.
* Using D3D9 fixed the underwater issues, except the underwater compositor still ticks way faster than it should.
* Still no above water reflections even though everything is setup as it should be.

== 2/16/15 ==
* By not loading the Hydrax config file, reflections are enabled. So something in the .hdx file is disabling them.
* Compiled latest community Hydrax source, testing.
* It seems setting <float>GlobalTransparency=0.5 enabled reflection along with everything else working fine.
* Reflections are working but SkyX doesn't seem to support full sky reflection, as seen in the demo.
* Removing the frame listener for SkyX and instead calling SkyX::notifyCameraRender() now renders SkyX reflections in the ocean!
* Fixed artifacts in sky by explicitly setting the Player camera's clipping distance to 0.f -- infinite.
* Hydrax reflections in NM_VERTEX may be reversed, NM_RTT is probably the best way to go.
* Only remaining Hydrax bugs: Underwater compositor is too fast, the edges underwater have a gap that can be seen through.
* Made Ocean an interface, created OceanHighGraphics which uses the Ocean interface. This vastly reduces the conditional branching in its functions.
* Made Sky an interface, created SkyHighGraphics for SkyX. Same idea as Ocean and OceanHighGraphics. Interfaces are nice.
* Moved day/night lighting logic out of Environment::update() into SkyHighGraphics::update().
* As of now I use a hack to hide the sun underwater for Hydrax, but eventually the "sun" could be changed to the moon's colour and corresponding light strength for more realism.
* (now 2/17):
* Added SkyPreset struct, and SkyHighGraphics can now load some presets for thunderstorms etc.
* SkyX lightning seems to have a bug; it only appears directly above the camera (which is very bad looking). A hack is to add 100 to the position in the vertex shader (SkyX_Lightning.hlsl), 
    which makes the lightning appear above the clouds, but no more lightning bolts.
* So nevermind that hack. SkyX also has problems with cameras attached to scene nodes like HydraX. I've created a camera just for SkyX updates in SkyHighGraphics, and lightning is as it should be!
* Using two cameras caused reflection issues with Hydrax. So if I want to use lightning Hydrax will be out of the question unless I find a way to fix it. 
    One workaround would be to add another cloud layer below the player and above Hydrax, and change the preset to not use lightning and reassign the camera pointer when Hydrax is seen.

== 2/18/15 ==
* Added proper cleanup code to Environment::destroy() for sky.
* Fixed the lightning position bug in SkyX. The calculation for where to place the lightning was using the camera's position plus its far clip distance, which in my case is 0.f, so it was 
    always positioned directly above the camera.
    The fix is simple, change the section of code in LightningManager.cpp that adds lightning to this (line 119 to 174):
                // Select a random camera to place the lightning
				if (!mVClouds->_getCamerasData().empty())
				{
					Ogre::Camera* c = mVClouds->_getCamerasData().at(mVClouds->_getCamerasData().size()*0.999).camera;
                    Ogre::Real farClipDist = c->getFarClipDistance();
                    if (farClipDist == 0.f){
                        // Infinite far clip distance, assign a random value.
                        farClipDist = Ogre::Math::RangeRandom(1.f, 99999.f * 6.f);
                    }

					Ogre::Real prob = Ogre::Math::RangeRandom(0,1);
                   
					// Cloud-to-ground
					if (prob < 0.5)
					{
						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(0,-1,0), 
							// Ray length
							mVClouds->getGeometrySettings().Height.x + 0.1*mVClouds->getGeometrySettings().Height.y);
					}
					// Cloud-to-cloud
					else if (prob < 0.7)
					{
						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(Ogre::Math::RangeRandom(-1,1),Ogre::Math::RangeRandom(-0.1,0.1),Ogre::Math::RangeRandom(-1,1)).normalisedCopy(), 
							// Ray length
							Ogre::Math::RangeRandom(0.5,1.5f)*0.2*mVClouds->getGeometrySettings().Height.y);
					}
					// Cloud-to-ground + cloud-to-cloud
					else
					{
						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(0,-1,0), 
							// Ray length
							mVClouds->getGeometrySettings().Height.x + 0.1*mVClouds->getGeometrySettings().Height.y);

						addLightning(
							// Ray position
                            Ogre::Vector3(c->getDerivedPosition().x + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5), mVClouds->getGeometrySettings().Height.x + 0.2*mVClouds->getGeometrySettings().Height.y, c->getDerivedPosition().z + Ogre::Math::RangeRandom(-farClipDist*0.5, farClipDist*0.5) / Ogre::Math::RangeRandom(1, 5)),
							// Ray direction
							Ogre::Vector3(Ogre::Math::RangeRandom(-1,1),Ogre::Math::RangeRandom(-0.1,0.1),Ogre::Math::RangeRandom(-1,1)).normalisedCopy(), 
							// Ray length
							Ogre::Math::RangeRandom(0.5,1.5f)*0.2*mVClouds->getGeometrySettings().Height.y);
					}

					updateMaterial();
				}

* I've temporarily added SkyX source directly into my project for debugging, it'll be removed for any production build.
* Added LightningManager.cpp to the repo for record keeping.
* Modified Entity system for more efficiency. Before it had getComponentPtr() which was slow and searched through the linked list of attached components. 
    Now there is an array based list (STL vector) of components which I call the component registry; it allocated enough space for all possible components. When a component is attached,
    its corresponding slot for its ID is set to point to the newly attached component, and additionally the new component pointer is added to the linked list I call "m_activeComponents".
    This changes retrieving a component pointer from an entity from O(n) to O(1) complexity at little cost of additional code.
* Component-specific getter functions have been added to Entity for each component(e.g., Entity::getCameraComponent(), Entity::getModelComponent(), etc.).
* Added ComponentDecls.hpp which forward declares all the Component types and the typedefs for pointers to them. This reduces repetition in header files.
* Added OceanLowGraphics using ocean shader from the Ogre samples, tested in debug mode.

== 2/20/15 ==
* Added Talos::Config class for basic ini parsing.
* Created Server class (compiled latest RakNet as well).
* Experienced a really strange bug where World::getPlayer() returned nullptr even after the player pointer was set(clearly seen within debugger). This occurred after adding Server and Client to
    the World::Dependencies struct, but forgetting to apply the pointers in World::injectDependencies(). After applying them in World.hpp the bug no longer occurred. Moved World::injectDependences()
    into World.cpp, then commented out the code that assigns the server and client pointers, and the bug still didn't occur. I don't know what caused this so for the record it's an unsolved bug.
* I fear the World class is slowly becoming a god object.
* Created Client class. Tested basic connection to server successfully.
* Engine holds a shared_ptr to both a Server and Client object. These are injected into the World of each engine state, so that each state can access them as needed.
* Server and Client are initialized using World::initServer() and World::initClient(). World::update() calls update on the Server or Client if one is registered.
* In using the RakNet::BitStream I accidently used and std::string which gets corrupted over the wire, you must use RakNet::RakString. 
* Created a Serialize() function for a test struct in Client for sending from the client to the server. All network data structures will need to be placed in one file.

== TODO ==
* Create header to define all data structures for network and declare their overloaded << and >> operators within the RakNet namespace.
* Create EventQueue system to deal with network and UI.
* Get rid of temporary server/client creation method and replace with GUI.
** Hydrax underwater is sped up, fix. (E:\Engine\Ogre3D\Hydrax-v0.5.1\Hydrax\Hydrax.vcproj to recompile).
* Shift input for sprint.
* Create a SkyX config file.
* Add a "clock speed" variable to the World, should affect physics etc.
* ActorComponent could use some redesign - CameraComponent is completely unnecessary, and AIComponent will be redundant.
* Put 16.f somewhere as a constant that every file can access (MS per update).
* Put character controller data into config file to speed up testing.
* Make PScene optional when initializing World.
* Make PhysX use software mode if NVIDIA card is not detected.
* Have a UI object (an interface) which defines functions for GUI events. Derive one for each state. It should have a queue of events that the EngineState::update() function processes.
* Enums appear to be at random places in class definitions, make them consistent.
* Have a pointer to an EntityFactor in World? (For creating specific Entities such as box, enemy, etc.)
* Have all classes that shouldn't be derived from be declared as final.
* Put an EntityRegistry in World which has an associative array of IDs to strings for Entity names.
* Make sure Entities are destroyed properly when World is destroyed.
* Alphabetize includes everywhere. Folder name is first if in a folder.
* Implement config file loading for options in Engine::init() and others.
* Refer to http://gameprogrammingpatterns.com/event-queue.html for Audio.
