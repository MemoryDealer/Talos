// ========================================================================= //
// Talos - A 3D game engine with network multiplayer.
// Copyright(C) 2015 Jordan Sparks <unixunited@live.com>
//
// This program is free software; you can redistribute it and / or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or(at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
// ========================================================================= //
// File: work-log.txt
// Author: Jordan Sparks <unixunited@live.com>
// ========================================================================= //
// A log of all work done on the program.
// ========================================================================= //

== 1/19/15 - 1/26/15 ==
* Read "Game Programming Patterns" by Robert Nystrom in hopes to build a strong design background before starting.

== 1/26/15 ==
'''Prepared for building a consolidated engine.'''
* Built Ogre3D dependencies--FreeImage, FreeType, zlib, and zziplib.
* Built Ogre3D(1.9.0) binaries from latest source.
* Applied for NVIDIA GameWorks to acquire PhysX SDK, then downloaded Core PhysX SDK(3.3.2).
* Built RakNet(4.081) binaries.
* Built CEGUI(0.8.4) binaries (getting CMake to work for this was a little tricky).
* Acquired irrKlang(1.5.0) SDK.
* Acquired SDL2(2.0.3) development libraries.
'''---'''
* Created Visual Studio 12.0 solution. Added main.cpp, compiled and linked with Ogre3D and Boost successfully.
* Created Engine class, which initializes Ogre and will manage the engine states (menu, game, pause, etc.).
* Added stdafx.hpp.
* Added EngineState class, which is abstract; derived classes represent a single state that can be active at a time. The IntroState has been created as a test.
* Added EngineState::injectDependencies() which as of now takes pointers to Ogre::Root and Ogre::Viewport initialized by Engine. This can be later expanded to take a struct or perhaps generics. The prevents me from having to use Engine as a singleton by giving each EngineState the objects they need.
* Tested basic game loop updating and active state updating.

== 1/27/15 ==
* Added Engine::registerState(). This should be called in for each state that will be needed during initialization.
* Added Assert(exp, desc) macro, which tests an expression for true and offers the option to break into the debugger if the expression is false. A description is also supplemented for each Assert.
* Added HelperFunctions.hpp which for now contains a generic toString() function for converting just about anything to std::string.
* Tried to add a basic mesh and a prefab cube and render it with Direct3D11, however errors were occurring which probably had to do with the shaders I'm using or a bug in the engine. Apparently, Direct3D11 support is not even fully implemented yet, so I may have to use the OpenGL rendering system for the duration of this project.
* OpenGL shaders working on a basic mesh.
* Implemented a game loop that uses a fixed time step when updating the state but adjusts for lost time during the rendering phase. Once physics support has been added, it should be "free" and hence the game world will be deterministic.
* Researched some Entity-component system implementations. Everyone seems to have their own way of doing it, so I'll just have to try it. One of my main goals is to store the components in contiguous memory to optimize cache hits.

== 1/28/15 ==
* Created base Component and Entity classes. These are abstract; Component can be derived from into a chain (e.g., Component <- InputComponent <- DemoInputComponent) and Entity should only be derived from once per entity (e.g., Entity <- Player, Entity <- Elevator, Entity <- Gun).
* Created SceneComponent which holds an Ogre::SceneNode to hold the transform in the game world.
* Made System interface. Each type of component should have its own system (e.g., PhysicsSystem, SceneSystem, ModelSystem, etc.).
* Created World class which will hold all data for the game world. Each EngineState has one.
* Created CameraComponent.
* Created Player class derived from Entity. Added a SceneComponent and CameraComponent. Tested for rendering successfully.

== 1/29/25 ==
* Modified Entity class to have init(), destroy(), and update() functions implemented. All of these simply traverse the list of Components stored in the Entity. 
* Component now has pure virtual methods init(), destroy(), update(), all of which take EntityPtr and World& parameters.
* Added SceneComponent::attachObject() which takes an Ogre::MovableObject* and attaches it to the internal Ogre::SceneNode*.
* Created EntityPool class, which has O(1) creation time when retrieving the next available Entity from the contiguous array.
* Delegated Entity creation to the World class, which holds an EntityPool and calls upon it internally.
* Decoupled SceneComponent from CameraComponent::init(). Use CameraComponent::getCamera() and pass it into SceneComponent::attachObject().
* Added FirstPersonComponent which sets up a system of nodes that control a first person camera.
* Added SDL2 and associated the SDL window with the window created by Ogre. 
* Added Message struct in Component folder. Also enums for message types.
* Tested input with SDL, setup mouse motion event to move camera.

== 1/30/15 ==
* Added Entity::message() which broadcasts a message to all attached components.
* Created InputComponent which detects input and sends a corresponding message to the parent Entity.
* Added pitch limitation in FirstPersonComponent, so the camera can't be pitched to an upside down state.
* Made World a friend class of EntityPool, added World::update() which iterates through the EntityPool and calls update on each Entity.

== 1/31/15 ==
* Created ComponentPool generic class. 
* Added ComponentPool instances to World for each type of Component. This increases coupling here but Component creation can be confined to the World class rather than allowing dynamic allocation on the fly.
* Tested an Entity with an ogrehead.mesh ModelComponent. It rotates at the same rate regardless of frame rate, so my update architecture is indeed frame rate indepedent. Just the mouse relative coordinates depend on the frame time.

== 2/2/15 ==
* Removed EngineState::injectDepedencies and created World::injecteDependencies. It's called in Engine::registerState().
* Added World::Dependencies struct for easy parameter passing and change if needed.
* Started integrating CEGUI. Turns out after compiling CEGUi it generated three headers (Config.h, ModuleConfig.h, and Version.h) which should be copied to the main include directory for CEGUI.
* Got a basic CEGUI window setup inside the viewport.
* Synced the CEGUI mouse position using GUIContext::injectMousePosition().
* Removed window creation from Ogre and let SDL create the window. This way, I have more control over mouse behavior without having to resort to Win32 API. So I can now lock the mouse at the center for camera movement. It can be
    disable for using the GUI. After the SDL_Window is created, Ogre calls Root::createRenderWindow() using a window handle parameter retrieved from the SDL_Window. 
    The call to CEGUI::OgreRenderer::bootstrapSystem() also needs a dereferenced Root::getRenderTarget("window name") for initialization.
* Added Input class which takes SDL events and handles them, for player input and GUI input.
* Removed InputComponent as the new Input class takes over. 

== 2/3/15 ==
* Added Observer and Subject classes. 
* Made Engine derive from Observer; it receives notifications from EngineStates. So if it receives a "POP" notification from the active state, it will pop that state.

== 2/6/15 ==
* Renamed FirstPersonComponent to ActorComponent, which can be used to control an Entity using either a player, AI, or network player (also replays).
* Added Command interface class. Command::execute() takes an EntityPtr and can retrieve the components it might need from that pointer.
* Added a std::map to the Input class to hold a keymap for all keys on the keyboard. 
* Created CommandRepository which holds a smart pointer to each Command needed in the game. The input class holds an instance of CommandRepository to assign pointers to its keymap.
* Created NullCommand as per the Null Object pattern.
* Moved Input to Engine, so there is a single instance. It is injected into EngineStates.
* Moved mouse looking control out of ActorComponent::message() and into look(). The MouseMove Command calls look().
* Added getActorComponent() to Entity since the actor component needs to be retrieve so many times. This is messy IMO but a good decision to avoid repeating myself.
* It seems that NVIDIA doesn't know how to compile for the current visual studio version...I used the .sln file for the extensions library after changing the Runtime Library option in C/C++ -> Code Generation to /MDd which was previously /MTd. The new .lib file works.

== 2/7/15 ==
* Created Physics class, which is part of Engine. It initializes the base PhysX objects: PxFoundation and PxPhysics. It is passed into PScene:
* Created PScene class, which is part of World. It contains a PxScene which holds data for a single scene of physics simulation.
* Made a simple PxRigidDynamic test in IntroState, applied it to the Ogre mesh. I believe I have the simulate() correct on the physx scene, at 1.f / 16.f (16. is the MS_PER_UPDATE in Engine).
* Got a sample sphere rigid dynamic actor to roll off a static box actor. Next I must integrate this code into components.

== 2/8/15 ==
* Added loadMeshes() in Resources.cpp, which is called after loadOgreResources() in Engine::init(). For now it just creates a mesh in memory to be used for a plane.
* Created PhysicsComponent, which holds either a static or dynamic PhysX actor.
* Modified Component initialization to use an overloaded init() function rather than one or more set*() functions. This minimizes the setup code for Entities(however still large, should be moved to factory functions).
* Also modified the attach*() functions for Components to take the proper Component rather than the internal data (such as Ogre::Camera etc.); it is all done internally within the Component.
* Added several wrapper functions for PhysicsComponent to modify the Entity's location and rotation. rotate() however does not affect the PhysX transform and I don't know why.
* Tested both a static plane and dynamic sphere using the PhysicsComponent. Tested rotating the plane with quaternion black voodoo magic to a 45 degree angle with success. 
* Added the PhysX kinematic character controller to ActorComponent. This also required a controller manager to be setup in the PScene. Got a simple movement system working, it will take much more experimentation and work to get it right. 

== 2/9/15 ==
* After a considerably long time of experimentation, I've converted the PhysX units to a 1 unit = 1 meter scale.
* Fixed pause when changing directions while moving.
* Created KCC (Kinematic Character Controller) class to encapsulate PhysX controller. The ActorComponent allocates it. Also made DCC(Dynamic ..) which will be implemented at a later time.
* Fixed player movement to move at the same speed regardless of the camera's pitch.
* Added DynamicRenderable class from Ogre3D website.
* Added DynamicLines class for drawing debug lines or for any need of line drawing.
* Added ability for DynamicLines to translate, each instance has an origin vector3 which specifies the starting offset of the points.
* Created my own debug drawer for PhysX - PDebugDrawer. It takes PxRigidActor and PxGeometry as parameters and adds them to a list of debug nodes, each of which contain a DynamicLines instance 
    representing the actor's geometry. It can be enabled by calling PScene::loadDebugDrawer().
* I've changed the convention for Entities: instead of calling Entity::init() after all Components are attached, Component::init() should be called on every Component before it's attached. This prevents
    any nullptrs when Components need each other's data. Then, World::checkEntities() is called after scene creation, which checks if every Component attached to every Entity has been initialized. 
* Put in about 10 hours today.

== 2/10/15 ==
* Not much time to work today :(
* Added default material to PScene which is used by PhysicsComponent.
* Renamed MouseMoveCommand to LookCommand. This makes more sense for Actors being controlled by AI.

== 2/11/15 ==
* Changed Component's name string to an enum type for faster run-time checking.
* Added LightComponent, created point light as test.
* Replaced ComponentPool with Pool, which uses proper template instantiation in the cpp file, reducing compile times.
* Added SpectatorCommand to switch player into spectator mode temporarily while holding down a key (space at the moment).

== 2/12/15 ==
* Unsuccessfully tried to integrate Havok physics, but could not compile with visual studio 2013 as the free binaries were only 2012. If I am to use Havok, I'll have to obtain a license...when I have 40k+.
* Changed header of every file to GPL v3.0. Added LICENSE and README.md, uploaded to Github.

== 2/13/15 ==
* Added World::setFog(). 
* Replaced all tabs with 4 spaces. Changed visual studio to insert spaces for tabs.

== TODO ==
* Add a "clock speed" variable to the World, should affect physics etc.
* Put character controller data into config file to speed up testing.
* Make PScene optional when initializing World.
* Make PhysX use software mode if NVIDIA card is not detected.
* Have a UI object (an interface) which defines functions for GUI events. Derive one for each state. It should have a queue of events that the EngineState::update() function processes.
* Enums appear to be at random places in class definitions, make them consistent.
* Have a pointer to an EntityFactor in World? (For creating specific Entities such as box, enemy, etc.)
* Have all classes that shouldn't be derived from be declared as final.
* Put an EntityRegistry in World which has an associative array of IDs to strings for Entity names.
* Make sure Entities are destroyed properly when World is destroyed.
* Alphabetize includes everywhere. Folder name is first if in a folder.
* Implement config file loading for options in Engine::init() and others.
* Refer to http://gameprogrammingpatterns.com/event-queue.html for Audio.
